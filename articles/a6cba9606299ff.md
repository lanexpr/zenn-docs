---
title: "heftia 0.4"
emoji: "😊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに
この記事は、今回Heftiaをv0.3からv0.4にアップデートするにあたり行った、各種パフォーマンス最適化テクニックの調査及び改善の記録です。

## Heftiaにおける焦点
まずパフォーマンスの改善の前に、Heftiaが何を重視するかの方針を述べます。パフォーマンス改善はすべて、この方針に反しない範囲で行われます。
少し長くなりますので読み飛ばしても問題ありません。

Heftiaは、エフェクトシステムとして特に意味論の整合性を重視します。これは、ユーザーに一貫した予測可能なエフェクト解釈の挙動を提供するためのものです。

Heftiaはその方針として、以下の4つに焦点を当てます。

1. 代数的エフェクト (Algebraic Effects and Handlers) の機能のすべてを、一切の妥協なしにフルに使用可能であること

    * これには継続の操作、そしてその解釈スコープ外への持ち出し (Non-Scoped Resumption; 特に、Coroutine。) が含まれます

2. AEaHを、その意味論を保ったまま--すなわち「壊れた挙動になり得ない」よう安全に--高階エフェクトへと完全に拡張したものであること
    * 特に、安全の範囲内で、可能な限りのありうるすべての自由度をユーザーに提供することを目指します。

3. エフェクトを使用するユーザーだけでなく、エフェクトを新たに定義するユーザーにもフレンドリーであること
    * 特に、継続を操作するようなエフェクトやハンドラーを、特段の注意なしに気軽に、軽量に利用できるようにすること

4. IO-fusedな解釈に限定されないこと--すなわち、IOモナドレベルの操作から意味論がisolateされていること

1.については、端的に言えばkokaのようなエフェクトが組み込まれた先進的な言語と等しい能力を持つということです。
エフェクトシステムは、代数的になることでその真の能力を発揮することができます。

2.についてですが、これがまさにHeftiaにとって重要です。
この拡張は、Freerのデータ構造に非常にシンプルな、ほんのちょっとの改変を加えることで実現されます (Hefty Algebraに基づく一階エフェクトシステムの高階化)。
この方法では、**高階エフェクトに対するありうる全ての可能な操作はそのデータ構造からほとんど自明に導かれます**。
そして、**安全でないような操作は常に型エラーとなり、そのような操作を関数として書くことはできません。**
高階化拡張に際して、スマートコンストラクタのような安全性のためのアドホックなガードレールは一切使用されていません。
構造からの自明な導出、これが整合性のために重要なのです。

3.については、モナドトランスフォーマーの文化のように、便利で面白い様々な機能を実現できるエフェクトをユーザーが気軽に発明できるようなライブラリを目指したいということです。
これはいわば「エコシステムの拡張可能性」です。

最後に4.について。これは少し説明が必要です。

### IO-fusedについて

まず背景として、近年のエフェクトシステムはここで新たに導入する概念である「IO-fused」なライブラリが多くなってきています。これはパフォーマンス上の理由です。
頻繁に使用されるエフェクトである`State`は特に、その内部実装として`StateT`や`Freer`を使用するよりも`ReaderT IORef IO`のような方法で処理するほうが高速です。
この方法は、*ReaderT IOパターン*と呼ばれています[^1]。`Effectful`ライブラリはこの方式です。
また、GHC 9.6以降でサポートされているGHC control/prompt プリミティブ命令に基づく方法は、`Freer`に基づく継続の操作よりも高速であるため、期待されてきました。
これを利用できるライブラリとして`eff`や`speff`が存在します。

[^1]: エビデンスパッシングスタイルという言葉が使われることもありますが、実際のところEPSは必ずしもIO-fusedであるとは限らないのではないかと考えています。

`ReaderT IORef`にせよGHC primopsにせよ、これらはIOモナドのレベルで動作します。
これは基本的に良く動作しますが、「状態と継続の乖離」を引き起こすことに注意が必要です。
例えば、継続を操作する次のようなプログラムを考えてみてください:

```haskell
program = runState 0 . runCC $ do
    k <- getCC
    modify (+1)
    print =<< get
    k ()

```

`getCC`は、その位置からの継続を取り出して返却します。後からこの継続を呼び出すと、その時点にまで「巻き戻され」ます。あたかもタイムマシンのように。
おさらいになりますが、継続とはこのようにgotoのようなものなのでした。ただしgotoと言っても、カオスな乱用を防ぐために能力が制限されたバージョンであって (delimited continuation)、しかも型安全です。

さて、このプログラムの実行結果として、まず

```console
0
1
2
3
...
```

というものがありうるでしょう。はい、これはいわゆる制御構造のジャンプです。

しかし代数的エフェクトは本質的に、さらなる能力を有しています。すなわち、単純に制御構造をジャンプさせるというだけでなく、**実際にタイムマシンになることができるのです**:

```console
0
1
1
1
...
```

まずプログラム、初期状態として`0`からスタートします。`getCC`は継続を取り出しますが、この場合の継続には現在のカウンタの状態が含まれているのです。
そのため、継続を後から呼び出すと、単にジャンプするだけでなく、状態もまたその時点にまでロールバックされます。
このように状態が継続に織り込まれているようなスタイルは、*continuational state*とでも呼ぶと良いでしょう[2]。
代数的エフェクトのもつcontinuation-based semanticsは、継続に関してこのように振る舞うのがデフォルトで、もっとも単純な場合の挙動です。

[^2]: これは`fused-effects`や`Polysemy`におけるWeaving意味論を特徴付ける概念である`functorial state`との対比を意識しています。

継続をサポートするIO-fusedなエフェクトシステム（`eff`、`eveff`、`mpeff`、`speff`など）は、基本的に前者の振る舞いのみを効率的にサポートします。
後者の振る舞いを実現することは不可能ではありませんが、その場合Freerの方法と比べて低速になり、パフォーマンスのメリットが失われます。
一方でFreerは、どちらの振る舞いも実現でき、かつ両者ともにフラットなパフォーマンス特性を持ちます。

おそらく、Haskellの既存のエフェクトシステムに慣れ親しんだ人々は後者の振る舞いに驚くでしょう。
後者のような振る舞いは不要な複雑性で、驚き最大であり、直感に反すると主張するかもしれません。

しかし、これは代数的エフェクトというパラダイムと既存のHaskellライブラリのパラダイムとの齟齬が原因です。思考の枠組みを一旦変える必要があるのです。
代数的エフェクトのパラダイムは、リダクションと呼ばれる項書換え・操作的意味論による一貫した形式で与えられ、習得によって最小の認知負荷で挙動が予測できるようになります。
つまり、コードを見たとき、内部でどのようなことが行われるかを一切意識せずに、「表面上の・構文上の見た目のまま」機械的に変形していくことで解釈の結果が予測できるということです。

アドホックな例外事項、leaky abstractionは一切ありません。
「非同期例外が飛んでくるかもしれない」「例外マスキングの状態はいまどうなっているのか」「この状態・環境値は局所的だからスレッド間で共有されない」といった、
**IOレベルの内部実装、内部状態的な、雑多な意味論からは完全にisolateされており、挙動の予測には一切影響せず、意識する必要はありません**。
これが、IO-fusedから自由であることの明確なメリットです。
ユーザーは従来通り、純粋関数型言語の名の下に、IOモナドをinstruction scriptを表す何も特別ではない単なるopaqueなデータ構造と考え、それをメタプログラミングするつもりでエフェクトフルプログラムを書けばよいのです。

とは言っても、これはあくまで理想的な話です。現実的には、プログラマにとっての利便性よりもパフォーマンスのほうがずっと重要である状況でもエフェクトシステムを使いたいというニーズがあることを理解しています。
エフェクトの投げられる頻度（単位時間辺りのエフェクト送信数）がそこまで高くなく、メインの計算処理のほうがずっと重いケースは良いのですが、
特にエフェクト送信の頻度が高い場合はエフェクトライブラリ自体のパフォーマンスが重要になってきます。
そのようなケースを考慮してHeftiaでは、特にIO-fusedな方式の他ライブラリとの相互運用性を提供する予定です。
