---
title: "Heftiaã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå…¥é–€ Part 2 - é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆ"
emoji: "ğŸ¥"
type: "tech"
topics: []
published: false
---

ã“ã“ã§ã¯ã€ãƒ­ã‚®ãƒ³ã‚°ã®ãŸã‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é€šã˜ã¦ã€heftia-effectsã«ãŠã‘ã‚‹é«˜éšã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–ã‚Šæ‰±ã„æ–¹ã‚’èª¬æ˜ã—ã¾ã™ã€‚ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã»ã¨ã‚“ã©æ—¢å­˜ã®Freerã«åŸºã¥ããƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨åŒæ§˜ã§ã‚ã£ãŸã®ã«å¯¾ã—ã¦ã€heftia-effectsã«ãŠã‘ã‚‹é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ‰±ã‚ã‚Œæ–¹ã¯ã€[Hefty Algebras (Casper et, al. 2023)](https://dl.acm.org/doi/10.1145/3571255)ã«åŸºã¥ãã€ã¾ã£ãŸãæ–°ã—ã„ã‚‚ã®ã§ã™ã€‚

ä»¥é™ã€å¸¸ä½“ã§è§£èª¬ã‚’è¡Œã„ã¾ã™ã€‚

# æº–å‚™
ã“ã®ãƒ‘ãƒ¼ãƒˆã§ã¯ã€å¤–éƒ¨ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦[`time ^>= 1.11.1`](https://hackage.haskell.org/package/time), [`text ^>= 1.2.5`](https://hackage.haskell.org/package/text)ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

# ãƒ­ã‚°å‡ºåŠ›ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹

ã¾ãšã€å¾©ç¿’ã‚‚å…¼ã­ã¦å¿…è¦ãªä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¦ã„ã“ã†ã€‚
ãƒ­ã‚®ãƒ³ã‚°ã‚’è¡Œã†ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã€ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã§ãã‚‹:

```haskell
import Data.Text (Text)

data Log a where
    Logging :: Text -> Log ()
makeEffectF [''Log]
```

ã“ã‚Œã«å¯¾ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¨ã—ã¦ä¾‹ãˆã°ã€å˜ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãã®ã¾ã¾æ¨™æº–å‡ºåŠ›ã«è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ã™ã‚‹:

```haskell
logToIO :: (IO <| r, ForallHFunctor eh) => eh :!! LLog ': r ~> eh :!! r
logToIO = interpretRec \(Logging msg) -> liftIO $ T.putStrLn msg
```

ãªãŠã€ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã«é–¢ã—ã¦ã¯çœç•¥ã€‚

# æ™‚åˆ»å–å¾—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ

æ¬¡ã«ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å°å…¥ã§ãã‚‹ã€‚

```haskell
import Data.Time (UTCTime, getCurrentTime)

data Time a where
    CurrentTime :: Time UTCTime
makeEffectF [''Time]

timeToIO :: (IO <| r, ForallHFunctor eh) => eh :!! LTime ': r ~> eh :!! r
timeToIO = interpretRec \CurrentTime -> liftIO getCurrentTime
```

ãã—ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ãƒ­ã‚°ã«ç¾åœ¨æ™‚åˆ»ã‚’ä»˜åŠ ã™ã‚‹å†è§£é‡ˆé–¢æ•°ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```haskell
import Data.Time.Format (defaultTimeLocale, formatTime)

logWithTime :: (Log <| ef, Time <| ef, ForallHFunctor eh) => eh :!! ef ~> eh :!! ef
logWithTime = interposeRec \(Logging msg) -> do
    t <- currentTime
    logging $ "[" <> iso8601 t <> "] " <> msg

iso8601 :: UTCTime -> Text
iso8601 t = T.take 23 (T.pack $ formatTime defaultTimeLocale "%FT%T.%q" t) <> "Z"
```

è©¦ã—ã¦ã¿ã‚ˆã†ã€‚

```haskell
main :: IO ()
main =
    runEff . logToIO . timeToIO . logWithTime $ do
        logging "foo"
        logging "bar"
        logging "baz"
        logging "baz"
        logging "qux"
        logging "quux"
```

å®Ÿè¡Œçµæœ:
```console
[2024-08-30T15:19:42.568Z] foo
[2024-08-30T15:19:42.568Z] bar
[2024-08-30T15:19:42.568Z] baz
[2024-08-30T15:19:42.568Z] baz
[2024-08-30T15:19:42.568Z] qux
[2024-08-30T15:19:42.569Z] quux
```

ã“ã“ã¾ã§ã¯ Part 1 ã§èª¬æ˜ã—ãŸé€šã‚Šã ã€‚

# ãƒ­ã‚°ã®ã‚¹ã‚³ãƒ¼ãƒ—åŒ–
ã•ã¦ã€ã“ã“ã‹ã‚‰ã¯é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¾‹ã‚’è¦‹ã¦ã„ã“ã†ã€‚

ãƒ­ã‚°ã‚’å‡ºåŠ›ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚¹ã‚³ãƒ¼ãƒ—ã§åŒºåˆ‡ã£ã¦ã€åå‰ã®ä»˜ã„ãŸã²ã¨ã¾ã¨ã¾ã‚Šã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¡¨ç¾ã™ã‚‹ã€æ¬¡ã®ã‚ˆã†ãªé«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å°å…¥ã—ã¦ã¿ã‚ˆã†ã€‚

```haskell
import Data.Effect.TH (makeEffectH)

-- | An effect that introduces a scope that represents a chunk of logs.
data LogChunk f (a :: Type) where
    LogChunk ::
        -- | chunk name
        Text ->
        -- | scope
        f a ->
        LogChunk f a
makeEffectH [''LogChunk]
```

æ–°ãŸã«ç™»å ´ã—ãŸ`makeEffectH`ã¯ã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ã®ãŸã‚ã®è‡ªå‹•å°å‡ºTHã ã€‚

ã¾ãšã€ç‰¹ã«ä½•ã‚‚ã›ãšã€åå‰ã®æƒ…å ±ã‚‚åˆ©ç”¨ã—ãªã„ã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã®ãƒ­ã‚°ã‚’ãã®ã¾ã¾ä¿æŒã—ã¦ã‚¹ã‚³ãƒ¼ãƒ—ã®æ§‹é€ ã®ã¿ã‚’æ¨ã¦ã‚‹é«˜éšãªè§£é‡ˆé–¢æ•°ã‚’æ›¸ã„ã¦ã¿ã‚ˆã†ã€‚

```haskell
import Control.Effect.Hefty (interpretRecH)

-- | Ignore chunk names.
runLogChunk :: ForallHFunctor eh => LogChunk ': eh :!! ef ~> eh :!! ef
runLogChunk = interpretRecH \(LogChunk _ m) -> m
```

`interpretRecH`ã¯ã€`interpretRec`ã®é«˜éšç‰ˆã ã€‚
ã™ã‚‹ã¨ã€ã“ã®`LogChunk`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¦ä½¿ãˆã‚‹:

```haskell
logExample :: (LogChunk <<: m, Log <: m, MonadIO m) => m ()
logExample = do
    logging "out of chunk scope 1"
    logging "out of chunk scope 2"
    logging "out of chunk scope 3"
    logging "out of chunk scope 4"

    liftIO $ putStrLn "------"

    logChunk "scope1" do
        logging "in scope1 1"
        logging "in scope1 2"
        logging "in scope1 3"
        logging "in scope1 4"

        liftIO $ putStrLn "------"

        logChunk "scope2" do
            logging "in scope2 1"
            logging "in scope2 2"
            logging "in scope2 3"
            logging "in scope2 4"

        liftIO $ putStrLn "------"

        logging "in scope1 5"
        logging "in scope1 6"

main :: IO ()
main = runEff . logToIO . timeToIO . logWithTime . runLogChunk $ logExample
```

å®Ÿè¡Œçµæœ:
```
[2024-08-30T15:39:17.645Z] out of chunk scope 1
[2024-08-30T15:39:17.645Z] out of chunk scope 2
[2024-08-30T15:39:17.645Z] out of chunk scope 3
[2024-08-30T15:39:17.645Z] out of chunk scope 4
------
[2024-08-30T15:39:17.645Z] in scope1 1
[2024-08-30T15:39:17.645Z] in scope1 2
[2024-08-30T15:39:17.645Z] in scope1 3
[2024-08-30T15:39:17.646Z] in scope1 4
------
[2024-08-30T15:39:17.646Z] in scope2 1
[2024-08-30T15:39:17.646Z] in scope2 2
[2024-08-30T15:39:17.646Z] in scope2 3
[2024-08-30T15:39:17.646Z] in scope2 4
------
[2024-08-30T15:39:17.646Z] in scope1 5
[2024-08-30T15:39:17.646Z] in scope1 6
```

ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è§£é‡ˆã™ã‚‹ã“ã¨ã‚’*ãƒãƒ³ãƒ‰ãƒ«/ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°*ã¨å‘¼ã¶ã®ã«å¯¾ã—ã¦ã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è§£é‡ˆã™ã‚‹ã“ã¨ã¯**æ•·è¡**ã€ˆãµãˆã‚“ã€‰ (**elaborate/elaboration**) ã¨å‘¼ã¶ï¼ˆHeftiaã«ãŠã„ã¦ã¯ï¼‰[^3]ã€‚ã“ã‚Œã¯æ–¹å¼ã®åå‰ã§ã‚‚ã‚ã‚‹ã€‚Heftiaã¯ã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä»•çµ„ã¿ã«æœ€æ–°ã®ã€*Hefty Algebraã«ã‚ˆã‚‹æ•·è¡æ–¹å¼*ã‚’æ¡ç”¨ã—ã¦ã„ã‚‹ã€‚

[^3]: ç­†è€…ã«ã‚ˆã‚‹elaborationã®è¨³èªã€‚

ã•ã¦ã€`LogChunk`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦ã€ä½•ã‹é¢ç™½ã„ã“ã¨ã‚’ã—ã¦ã¿ã‚ˆã†ã€‚

## ãƒ­ã‚°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜

ã¾ãšæº–å‚™ã¨ã—ã¦ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆæ“ä½œã€ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿æ“ä½œã‚’è¡¨ç¾ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã‚ˆã†ã€‚
```haskell
data FileSystem a where
    Mkdir :: FilePath -> FileSystem ()
    WriteToFile :: FilePath -> String -> FileSystem ()
makeEffectF [''FileSystem]

runDummyFS :: (IO <| r, ForallHFunctor eh) => eh :!! LFileSystem ': r ~> eh :!! r
runDummyFS = interpretRec \case
    Mkdir path ->
        liftIO $ putStrLn $ "<runDummyFS> mkdir " <> path
    WriteToFile path content ->
        liftIO $ putStrLn $ "<runDummyFS> writeToFile " <> path <> " : " <> T.unpack content
```

ã“ã®ãƒãƒ³ãƒ‰ãƒ©ã¯ãƒ€ãƒŸãƒ¼ã§ã€æ“ä½œã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒæŠ•ã’ã‚‰ã‚ŒãŸã‚‰å˜ã«ãã®æ—¨ã‚’å‡ºåŠ›ã™ã‚‹ã ã‘ã®ã‚‚ã®ã [^1]ã€‚

[^1]: ã‚‚ã¡ã‚ã‚“ã€å®Ÿéš›ã«IOã‚’è¡Œã†ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’æ›¸ãã“ã¨ã¯å®¹æ˜“ã§ã‚ã‚‹ã€‚

ãã—ã¦ä»¥ä¸‹ã¯ã€`LogChunk`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹ãŸã³ã«ã€ãã®ç¬é–“ã®æ™‚åˆ»ã®åå‰ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å†å¸°çš„ã«ä½œæˆã—ã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã«ãŠã„ã¦æŠ•ã’ã‚‰ã‚Œã‚‹ãƒ­ã‚°ã‚’ãã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¿å­˜ã™ã‚‹ã‚ˆã†ã«`LogChunk`åŠã³`Logging`ã‚’ãƒ•ãƒƒã‚¯ã™ã‚‹é–¢æ•°ã§ã‚ã‚‹ã€‚

```haskell
import Control.Effect.Hefty (raise, raiseH, interposeRec, interposeRecH)
import Data.Effect.Reader (LAsk, Local, ask, local)
import Control.Effect.Handler.Heftia.Reader (runReader)

-- | Create directories according to the log-chunk structure and save one log in one file.
saveLogChunk ::
    forall eh ef.
    (LogChunk <<| eh, Log <| ef, FileSystem <| ef, Time <| ef, ForallHFunctor eh) =>
    eh :!! ef ~> eh :!! ef
saveLogChunk =
    raise >>> raiseH
        >>> hookCreateDirectory
        >>> hookWriteFile
        >>> runReader @FilePath "./log/"
  where
    hookCreateDirectory
        , hookWriteFile ::
            (Local FilePath ': eh :!! LAsk FilePath ': ef)
                ~> (Local FilePath ': eh :!! LAsk FilePath ': ef)
    hookCreateDirectory =
        interposeRecH \(LogChunk chunkName a) -> logChunk chunkName do
            chunkBeginAt <- currentTime
            let dirName = T.unpack $ iso8601 chunkBeginAt <> "-" <> chunkName
            local @FilePath (++ dirName ++ "/") do
                logChunkPath <- ask
                mkdir logChunkPath
                a

    hookWriteFile =
        interposeRec \(Logging msg) -> do
            logChunkPath <- ask
            logAt <- currentTime
            writeToFile (T.unpack $ T.pack logChunkPath <> iso8601 logAt <> ".log") msg
            logging msg
```

ã¾ãšã€`<<|`å‹ãƒ¬ãƒ™ãƒ«æ¼”ç®—å­ã¯`<|`ã®é«˜éšç‰ˆã§ã‚ã‚‹ã€‚åˆ¶ç´„ã¯ã€é«˜éšå´ã§ã¯`LogChunk`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ãŒã€ä¸€éšå´ã§ã¯`FileSystem`,`Time`,`Log`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ãŒãƒªã‚¹ãƒˆå†…ã«å…¥ã£ã¦ã„ã‚‹ã“ã¨ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚

`raise`ã¯ã€ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆã®å…ˆé ­ã«æ–°ãŸã«ä»»æ„ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ ã™ã‚‹ã‚‚ã®ã :
```haskell
raise :: ForallHFunctor eh => eh :!! ef ~> eh :!! e ': ef
```
`raiseH`ã¯ã€`raise`ã®é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆç‰ˆã§ã‚ã‚‹:
```haskell
raiseH :: (ForallHFunctor eh => eh :!! ef ~> e ': eh :!! ef
```
ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆã‹ã‚‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æ¶ˆå»ã™ã‚‹ãŸã‚ã«ã¯è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¿…è¦ã ãŒã€å˜ã«è¿½åŠ ã™ã‚‹ã ã‘ãªã‚‰ç„¡åˆ¶é™ã«å¯èƒ½ã ã€‚

ãã—ã¦`>>>`æ¼”ç®—å­ã¯é–¢æ•°åˆæˆæ¼”ç®—å­`.`ã®å‘ãã‚’åè»¢ã•ã›ãŸã‚‚ã®ã§ã€ã“ã‚Œã¯Haskellã®æ¨™æº–ã§ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã ã€‚

å…¨ä½“ã®æµã‚Œã¯ã“ã†ã :

ã¾ãšã€`raise`,`raiseH`ã«ã‚ˆã‚Šã€å…¥åŠ›ã§å—ã‘ãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚ã‚‹
```haskell
eh :!! LLog ': ef
```
ã‚’
```haskell
Local FilePath ': eh :!! LAsk FilePath ': ef
```
ã¸ã¨å¤‰æ›ã™ã‚‹ã€‚

ã“ã“ã§`Local`ã¯`Reader`ç³»ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é«˜éšãªæ“ä½œã«å±ã™ã‚‹`local`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã€`Ask`ã¯ä¸€éšãª`ask`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾å¿œã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ã ã€‚ã“ã®ã‚ˆã†ã«Heftiaã§ã¯ã€å¾“æ¥ã®EEã§ã¯åŒºåˆ¥ã•ã‚Œã¦ã„ãªã‹ã£ãŸä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒç•°ãªã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ã¸ã¨åˆ†å‰²ã•ã‚Œã‚‹ã€‚ã“ã‚ŒãŒå¾“æ¥ã®EEã¨æ±ºå®šçš„ã«ç•°ãªã‚‹ç‚¹ã§ã‚ã‚Šã€ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç‰¹æ€§ã®é•ã„ã€ã™ãªã‚ã¡ãã‚Œãã‚Œã«å¯¾ã—ã¦å¯èƒ½ãªæ“ä½œã®é•ã„ã‚’ç­‹è‰¯ãæ‰±ã†ãŸã‚ã®ç§˜è¨£ã§ã‚ã‚‹ã€‚ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å¯èƒ½ãªã“ã¨ãŒã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒçµ¡ã‚€ã¨ä¸å¯èƒ½ã«ãªã£ãŸã‚Šã™ã‚‹ã®ã ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯å¾Œè¿°ã™ã‚‹ã€‚

ãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚ŒãŸ`Reader`ç³»ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ã¯ã€ä»Šç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å¯¾å¿œã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã‚’æ–‡è„ˆï¼ˆç’°å¢ƒå€¤ï¼‰ã¨ã—ã¦ä¿æŒã™ã‚‹ã€‚

ã•ã¦ã€ã“ã‚Œã§ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã‚’æ–‡è„ˆã¨ã—ã¦ä¿æŒã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã®ã§ã€`hookCreateDirectory`é–¢æ•°ã‚’ç”¨ã„ã¦LogChunkã®ãƒ•ãƒƒã‚¯ã«å…¥ã‚‹ã€‚

`interposeRecH`ã¯`interposeRec`ã®é«˜éšç‰ˆã ã€‚interposeã«éš›ã—ã¦ã€ä½•ã‚‚ã—ãªã„ã¨ãã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯æ¶ˆãˆã¦ã—ã¾ã†ã€‚ã¤ã¾ã‚Šä»Šå›ã®å ´åˆã€ä½•ã‚‚ã—ãªã‘ã‚Œã°`logChunk`ã®æ§‹é€ ã¯`interposeRecH`ã«ã‚ˆã‚Šå¤±ã‚ã‚Œã¦ã—ã¾ã†ã®ã ã€‚ãã“ã§ã€å†åº¦`logChunk`ã§å›²ã‚€ã“ã¨ã§ã€ã“ã®ãƒ•ãƒƒã‚¯ã®å¾Œã§ã‚‚ãƒ­ã‚°ãƒãƒ£ãƒ³ã‚¯ã®æ§‹é€ ã‚’å¤±ã†ã“ã¨ãªãã€ãƒ­ã‚°ãƒãƒ£ãƒ³ã‚¯ã®æ§‹é€ ã‚’åˆ©ç”¨ã—ãŸä»–ã®ãƒ•ãƒƒã‚¯ã‚’ç¹°ã‚Šè¿”ã—è¡Œã†ã“ã¨ãŒã§ãã‚‹ã€‚

æ–°ãŸãªè§£é‡ˆã®å†…éƒ¨ã§ã¯ã€`Time`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‹ã‚‰ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—ã—ã€ãã‚Œã¨ãƒãƒ£ãƒ³ã‚¯åã‚’çµ„ã¿åˆã‚ã›ãŸåå‰ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¤ã¤ã€`local`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã§ç’°å¢ƒå€¤ã‚’æ–°ãŸãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ã¨ç§»ã™ã€‚

æ¬¡ã«ã€`hookWriteFile`é–¢æ•°ã«ã¦ã€ãƒ­ã‚°ãƒãƒ£ãƒ³ã‚¯å†…éƒ¨ã®ã™ã¹ã¦ã®ãƒ­ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿æ“ä½œã‚’ãƒ•ãƒƒã‚¯ã™ã‚‹ã€‚ãã®éš›ã®ãƒ•ã‚¡ã‚¤ãƒ«åã¯ãã®ã¨ãã®æ™‚åˆ»ã ã€‚`hookCreateDirectory`é–¢æ•°ã‚’é€šã—ã¦æ—¢ã«ç’°å¢ƒå€¤ã¯LogChunkã®æ§‹é€ ã«å¾“ã£ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ç¾åœ¨ã®ã€ã„ã‚ã°ã“ã®æ–‡è„ˆã§ã®"ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª"[^2]ã¯`ask`ã§å–å¾—ã§ãã‚‹ã€‚

[^2]: å®Ÿéš›ã®OSã®ãƒ—ãƒ­ã‚»ã‚¹ã®çŠ¶æ…‹ã®æ„å‘³ã§ã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã¯ãªã„ã“ã¨ã«æ³¨æ„

æœ€å¾Œã«ã€`Reader`ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’åˆæœŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã‚’`"./log/"`ã¨ã—ã¦ãƒãƒ³ãƒ‰ãƒ«ã—ã¦ã„ã‚‹ã€‚

---

ä»¥ä¸Šã®é–¢æ•°ã‚’ä½¿ã†ã¨ã€ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹:

```haskell
import Data.Free.Sum (type (+))
import Control.Effect.ExtensibleFinal (type (!!))

runApp :: LogChunk !! FileSystem + Time + Log + IO ~> IO
runApp =
    runLogChunk
        >>> runDummyFS
        >>> logWithTime
        >>> timeToIO
        >>> logToIO
        >>> runEff

main :: IO ()
main = runApp . saveLogChunk $ logExample
```

å®Ÿè¡Œçµæœ:
```console
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.209Z.log : out of chunk scope 1
[2024-08-31T11:40:19.209Z] out of chunk scope 1
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.209Z.log : out of chunk scope 2
[2024-08-31T11:40:19.209Z] out of chunk scope 2
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.209Z.log : out of chunk scope 3
[2024-08-31T11:40:19.209Z] out of chunk scope 3
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.209Z.log : out of chunk scope 4
[2024-08-31T11:40:19.209Z] out of chunk scope 4
------
<runDummyFS> mkdir ./log/2024-08-31T11:40:19.210Z-scope1/
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z.log : in scope1 1
[2024-08-31T11:40:19.210Z] in scope1 1
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z.log : in scope1 2
[2024-08-31T11:40:19.210Z] in scope1 2
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z.log : in scope1 3
[2024-08-31T11:40:19.210Z] in scope1 3
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z.log : in scope1 4
[2024-08-31T11:40:19.210Z] in scope1 4
------
<runDummyFS> mkdir ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z-scope2/
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z-scope2/2024-08-31T11:40:19.210Z.log : in scope2 1
[2024-08-31T11:40:19.210Z] in scope2 1
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z-scope2/2024-08-31T11:40:19.210Z.log : in scope2 2
[2024-08-31T11:40:19.210Z] in scope2 2
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z-scope2/2024-08-31T11:40:19.210Z.log : in scope2 3
[2024-08-31T11:40:19.210Z] in scope2 3
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z-scope2/2024-08-31T11:40:19.210Z.log : in scope2 4
[2024-08-31T11:40:19.210Z] in scope2 4
------
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z.log : in scope1 5
[2024-08-31T11:40:19.210Z] in scope1 5
<runDummyFS> writeToFile ./log/2024-08-31T11:40:19.210Z-scope1/2024-08-31T11:40:19.210Z.log : in scope1 6
[2024-08-31T11:40:19.210Z] in scope1 6
```

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŸã¡ã‚’`IO`ã¸ã¨è§£é‡ˆã™ã‚‹ç³»ã®å‡¦ç†ã¯`runApp`é–¢æ•°ã¨ã—ã¦ã¾ã¨ã‚ãŸã€‚ã“ã“ã®å‹ã‚·ã‚°ãƒãƒãƒ£ã«ãŠã„ã¦å‡ºã¦ãã¦ã„ã‚‹`!!`ã‚„`+`ã¯ã€`:!!`ãŒå‹ãƒ¬ãƒ™ãƒ«ãƒªã‚¹ãƒˆã‚’ä½¿ã†ã®ã«å¯¾ã™ã‚‹ä»£æ›¿ã®è¨˜æ³•ã§ã€`eh`ã‚„`ef`ã‚„`r`ã¨ã„ã£ãŸå¤šç›¸åŒ–ã•ã‚ŒãŸãƒªã‚¹ãƒˆã®å‹å¤‰æ•°ãŒå‡ºç¾ã—ãªã„å ´åˆã“ã®ã‚ˆã†ã«ç°¡æ½”ã«æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚
```haskell
(LogChunk !! (FileSystem + Time + Log + IO)) ~> IO
```
ã®ã‚ˆã†ã«çµåˆã™ã‚‹ã€‚

çµæœã¯ã€ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹ãŸã³ã«å†å¸°çš„ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒä½œæˆã•ã‚Œã€ãã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å¯¾å¿œã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¿å­˜ã•ã‚Œã‚‹ã¨ã„ã†æŒ™å‹•ãŒå®Ÿç¾ã•ã‚Œã¦ã„ã‚‹ã€‚

## ãƒ­ã‚°ã®å‡ºåŠ›å›æ•°ã®åˆ¶é™

æ¬¡ã®ä¾‹ã«ç§»ã‚ã†ã€‚
ä»¥ä¸‹ã¯ã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§ãƒ­ã‚°ãŒ`n`å›ä»¥ä¸ŠæŠ•ã’ã‚‰ã‚ŒãŸå ´åˆã€`n`å›ä»¥é™ã¯çœç•¥ã—ã€çœç•¥ã•ã‚ŒãŸã“ã¨ã‚’ãƒ­ã‚°ã«å‡ºã™ã¨ã„ã†æŒ™å‹•ã¸ã®å†è§£é‡ˆã‚’è¡Œã†ãƒ•ãƒƒã‚¯ã§ã‚ã‚‹ã€‚

```haskell
import Control.Effect.Hefty (raiseUnder)
import Data.Effect.State (get, modify)
import Control.Effect.Handler.Heftia.State (evalState)

-- | Limit the number of logs in a log chunk to the first @n@ logs.
limitLogChunk :: Log <| ef => Int -> '[LogChunk] :!! LLog ': ef ~> '[LogChunk] :!! LLog ': ef
limitLogChunk n = reinterpretRecH $ elabLimitLogChunk n

elabLimitLogChunk :: Log <| ef => Int -> Elab LogChunk ('[LogChunk] :!! LLog ': ef)
elabLimitLogChunk n (LogChunk name a) =
    logChunk name do
        raise . raiseH $ limitLog $ runLogChunk $ limitLogChunk n a
  where
    limitLog :: Log <| ef => '[] :!! LLog ': ef ~> '[] :!! ef
    limitLog a' =
        evalState @Int 0 $
            raiseUnder a' & interpretRec \(Logging msg) -> do
                count <- get
                when (count < n) do
                    logging msg
                    when (count == n - 1) do
                        logging "Subsequent logs are omitted..."

                    modify @Int (+ 1)
```

`State`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯çŠ¶æ…‹ä»˜ãã®è¨ˆç®—ã‚’å®Ÿç¾ã™ã‚‹ã€‚

ã¾ãŸã€`raiseUnder`ã¯ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆã®å…ˆé ­`e1`ã®ã²ã¨ã¤ä¸‹ã«æ–°ãŸãªä»»æ„ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹`e2`ã‚’æŒ¿å…¥ã™ã‚‹:
```haskell
raiseUnder :: ForallHFunctor eh => eh :!! e1 ': ef ~> eh :!! e1 ': e2 ef
```

`reinterpretRecH`ã¯ã€åŸºæœ¬ã¯å˜ãªã‚‹`interpretRecH`ã ãŒã€å…¥åŠ›ã®å…ˆé ­ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹`e1`ã‚’æ–°ã—ã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹`e2`ã¸ã¨å¤‰æ›ã™ã‚‹ã¨ã„ã†ã‚ˆã†ãªãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ã‚’ã‚‚ã¡ã€ãã®ãŸã‚ã«`raiseUnderH`ãŒæŒ¿å…¥ã•ã‚Œã‚‹:
```haskell
reinterpretRecH ::
    (HFunctor e1, HFunctor e2, ForallHFunctor eh) =>
    (e1 (e2 ': eh :!! ef) ~> e2 ': eh :!! ef) ->
    e1 ': eh :!! ef ~> e2 ': eh :!! ef
reinterpretRecH i = interpretRecH i . raiseUnderH
```

å†…éƒ¨ã§ã¯ã€ãƒ­ã‚°ãŒæŠ•ã’ã‚‰ã‚Œã‚‹ãŸã³ã«çŠ¶æ…‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒä¿æŒã—ã¦ã„ã‚‹å€¤ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€ç¾åœ¨ã®ã‚«ã‚¦ãƒ³ãƒˆã«å¿œã˜ã¦ãƒ­ã‚°ã‚’å‡ºåŠ›ã—ãŸã‚Šã—ãªã‹ã£ãŸã‚Šã€çœç•¥ã•ã‚ŒãŸã“ã¨ã‚’è¡¨ã™ãƒ­ã‚°ã‚’å‡ºã—ãŸã‚Šã™ã‚‹ã€‚ãã—ã¦ã€`evalState`ã§ã‚«ã‚¦ãƒ³ã‚¿ã®åˆæœŸå€¤ã‚’0ã¨ã—ã¦çŠ¶æ…‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹ã€‚
ã¾ãŸå…ˆç¨‹ã¨åŒæ§˜ã€ãƒ•ãƒƒã‚¯å¾Œã‚‚LogChunkã®æ§‹é€ ã‚’æ®‹ã™ãŸã‚ã«ã€å…¨ä½“ã‚’`logChunk`ã§åŒ…ã‚“ã§ã„ã‚‹ã€‚

ã“ã“ã§ã€`Logging`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ãƒ•ãƒƒã‚¯ã‚’æ›ã‘ã‚‹ãŸã‚ã«`interposeRec`ã§ã¯ãªã`interpretRec`ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚ã“ã‚Œã¯ã€ãƒ•ãƒƒã‚¯å…ƒã®`Logging`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå…¥ã‚‹*ã‚¹ãƒ­ãƒƒãƒˆ*ã¨ãƒ•ãƒƒã‚¯å…ˆã®`Logging`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå…¥ã‚‹*ã‚¹ãƒ­ãƒƒãƒˆ*ã‚’åˆ†ã‘ã‚‹ã“ã¨ã§ã€**ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å¹²æ¸‰**ã‚’é˜²ããŸã‚ã§ã‚ã‚‹ã€‚*ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å¹²æ¸‰*ã«ã¤ã„ã¦ã¯å¾Œè¿°ã™ã‚‹ã€‚ã‚¹ãƒ­ãƒƒãƒˆã«ã¤ã„ã¦ã¯[Part 1 ã® ã‚¿ã‚°ä»˜ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ã®ç¯€](https://zenn.dev/articles/9061f0121f3cf5#%E3%82%BF%E3%82%B0%E4%BB%98%E3%81%8D%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E5%9E%8B)ã‚’å‚ç…§ã€‚

---

`limitLogChunk`é–¢æ•°ã‚’ä½¿ã†ã¨ã€æ¬¡ã®ã‚ˆã†ã«ã‚¹ã‚³ãƒ¼ãƒ—å†…ã®ãƒ­ã‚°ã®æ•°ãŒåˆ¶é™ã•ã‚Œã‚‹ã€‚LogChunkã‚¹ã‚³ãƒ¼ãƒ—å¤–ã®ãƒ­ã‚°ã«ã¤ã„ã¦ã¯ãã®ã¾ã¾ã«ãªã‚‹ã€‚

```haskell
import Control.Effect.Hefty (subsume)

main :: IO ()
main = runApp . subsume . limitLogChunk 2 $ logExample
```

```console
[2024-08-31T12:05:57.856Z] out of chunk scope 1
[2024-08-31T12:05:57.856Z] out of chunk scope 2
[2024-08-31T12:05:57.856Z] out of chunk scope 3
[2024-08-31T12:05:57.856Z] out of chunk scope 4
------
[2024-08-31T12:05:57.856Z] in scope1 1
[2024-08-31T12:05:57.856Z] in scope1 2
[2024-08-31T12:05:57.856Z] Subsequent logs are omitted...
------
[2024-08-31T12:05:57.856Z] in scope2 1
[2024-08-31T12:05:57.856Z] in scope2 2
[2024-08-31T12:05:57.856Z] Subsequent logs are omitted...
------
```

ã“ã“ã§`subsume`ã¯å…ˆé ­ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ãã‚Œã‚ˆã‚Šã‚‚ä¸‹ä½ã¸ã¨é€ä¿¡ã™ã‚‹é–¢æ•°ã :
```haskell
subsume :: (e <| ef, ForallHFunctor eh) => eh :!! LiftIns e ': ef ~> eh :!! ef
subsume = interpretRec sendIns
```
ã“ã‚Œã¯ã€ãƒ•ãƒƒã‚¯å…ƒã®`Log`ã®ã‚¹ãƒ­ãƒƒãƒˆãŒãƒ•ãƒƒã‚¯å¾Œã‚‚ã¾ã æ®‹ã£ã¦ãŠã‚Šã€LogChunkã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ã‚ã‚‹ãƒ­ã‚°ãŒãã“ã«ã¾ã å…¥ã£ã¦ã„ã‚‹ãŸã‚ã€ãã‚Œã‚‰ã‚’ã™ã¹ã¦ä¸‹ä½ã«å­˜åœ¨ã™ã‚‹ãƒ•ãƒƒã‚¯å…ˆã®`Log`ã‚¹ãƒ­ãƒƒãƒˆã¸ã¨é€ã‚Šåˆ‡ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚

ã“ã“ã¾ã§ã§é‡è¦ãªã®ã¯ã€**`State`ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒãƒ³ãƒ‰ãƒ«ã€ãã—ã¦ä¸€èˆ¬ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦*çŠ¶æ…‹ä»˜ãã®è§£é‡ˆ*ã‚’è¡Œã†ã¨ãã¯ã€åŸºæœ¬çš„ã«é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯æ—¢ã«ã™ã¹ã¦è§£é‡ˆæ¸ˆã¿ã§ã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆã¯ç©ºã«ãªã£ã¦ã„ãªã‘ã‚Œã°ãªã‚‰ãªã„**ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚ã“ã‚ŒãŒå…ˆã«è¿°ã¹ãŸã€ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å¯èƒ½ãªæ“ä½œã®é•ã„ã®ã“ã¨ã ã€‚ã‚ã‚‹é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æœªæ•·è¡ã®çŠ¶æ…‹ã§æ®‹ã—ã¤ã¤ã€ãã®ä»–ã®ä¸€éš/é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’çŠ¶æ…‹ä»˜ãã§è§£é‡ˆã™ã‚‹ã“ã¨ã¯ä¸å¯èƒ½ã§ã‚ã‚‹ã€‚çŠ¶æ…‹ä»˜ããªè§£é‡ˆã‚’è¡Œã†éš›ã¯ã€ã¾ãšæœ€åˆã«ã™ã¹ã¦ã®é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä¸€æ–‰ã«ã€åŒæ™‚ã«æ•·è¡ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚ã“ã‚Œã¯`interpretAllH`ç³»é–¢æ•°ã¨`|+:`æ¼”ç®—å­ã‚’ä½¿ã†ã“ã¨ã§å¯èƒ½ã ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ä»Šå¾Œã®ãƒ‘ãƒ¼ãƒˆã§èª¬æ˜ã§ãã‚Œã°ã¨æ€ã†ã€‚

çŠ¶æ…‹ä»˜ãè§£é‡ˆã«ã¤ã„ã¦ã¯ã€æœ¬ãƒ‘ãƒ¼ãƒˆã®å¾Œã‚ã®æ–¹ã§è©³ã—ãèª¬æ˜ã—ã‚ˆã†ã€‚

è§£é‡ˆãŒçŠ¶æ…‹ä»˜ãã§ãªã„å ´åˆã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒæœªæ•·è¡ã®çŠ¶æ…‹ã§ã‚‚è§£é‡ˆãŒå¯èƒ½ã ã€‚`interpretRec`ã®ã‚ˆã†ã«ã€å¾Œã‚ã«`Rec`ã¨ä»˜ã„ã¦ã„ã‚‹é–¢æ•°ã¯ã“ã®ãŸã‚ã«ã‚ã‚‹ã€‚`Rec`ã¯Recursivelyï¼ˆå†å¸°çš„ï¼‰ã®æ„å‘³ã§ã‚ã‚‹ã€‚é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯æ§‹é€ ã¨ã—ã¦ã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¹ã‚³ãƒ¼ãƒ—ã®ä¸­ã«ã•ã‚‰ã«é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å«ã‚€ã¨ã„ã†ã€æ½œåœ¨çš„ã«ç„¡é™ã«æ·±ã„æœ¨æ§‹é€ ã‚’æŒã£ã¦ã„ã‚‹ã€‚ã“ã®æœ¨ã®ãƒãƒ¼ãƒ‰ã¯é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã§ã‚ã‚Šã€ã‚¨ãƒƒã‚¸ã¯ãã®å¼•æ•°ã®ã†ã¡ã‚­ãƒ£ãƒªã‚¢å‹å¤‰æ•°`f`ã‚’å«ã‚“ã§ã„ã‚‹ã‚‚ã®ãŸã¡ã§ã‚ã‚‹ã€‚é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å«ã‚€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæœ¨æ§‹é€ ã‚’æˆã™ã¨ã„ã†ã®ã¯ã€å…ˆç¨‹ã®`logExample`é–¢æ•°ã‚’è¦‹ã‚‹ã¨ã‚ã‹ã‚‹ã ã‚ã†ã€‚`Rec`ç³»é–¢æ•°ã¯ã“ã®æœ¨æ§‹é€ ã«å¯¾ã—ã¦ã€ä¸€ç•ªæ·±ã„æ‰€ã‹ã‚‰æµ…ã„æ‰€ã«å‘ã‹ã£ã¦é †ç•ªã«è§£é‡ˆã‚„ãƒ•ãƒƒã‚¯ç­‰ã®å¤‰æ›æ“ä½œã‚’é©ç”¨ã™ã‚‹ã€‚

## ãƒ•ãƒƒã‚¯ã®åˆæˆ

ã•ã‚‰ã«ã€ã“ã®`saveLogChunk`ã¨å…ˆç¨‹ã®`limitLogChunk`ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã™ãªã‚ã¡ã€ãƒ•ãƒƒã‚¯ï¼ˆãã—ã¦ä¸€èˆ¬ã«æ•·è¡ï¼‰ã¯åˆæˆå¯èƒ½ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼ã ã€‚

ã“ã“ã§ã€åˆæˆã®é †ç•ªã«ã‚ˆã£ã¦æŒ¯ã‚‹èˆã„ãŒå¤‰ã‚ã‚‹ã€‚
`limitLogChunk`ãŒå…ˆã«é©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã¨
```haskell
main :: IO ()
main = runApp . saveLogChunk . subsume . limitLogChunk 2 $ logExample
```

å®Ÿè¡Œçµæœ:
```console
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.140Z.log : out of chunk scope 1
[2024-08-31T14:04:04.141Z] out of chunk scope 1
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z.log : out of chunk scope 2
[2024-08-31T14:04:04.141Z] out of chunk scope 2
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z.log : out of chunk scope 3
[2024-08-31T14:04:04.141Z] out of chunk scope 3
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z.log : out of chunk scope 4
[2024-08-31T14:04:04.141Z] out of chunk scope 4
------
<runDummyFS> mkdir ./log/2024-08-31T14:04:04.141Z-scope1/
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z-scope1/2024-08-31T14:04:04.141Z.log : in scope1 1
[2024-08-31T14:04:04.141Z] in scope1 1
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z-scope1/2024-08-31T14:04:04.141Z.log : in scope1 2
[2024-08-31T14:04:04.141Z] in scope1 2
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z-scope1/2024-08-31T14:04:04.141Z.log : Subsequent logs are omitted...
[2024-08-31T14:04:04.141Z] Subsequent logs are omitted...
------
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z-scope1/2024-08-31T14:04:04.141Z.log : in scope2 1
[2024-08-31T14:04:04.141Z] in scope2 1
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z-scope1/2024-08-31T14:04:04.141Z.log : in scope2 2
[2024-08-31T14:04:04.141Z] in scope2 2
<runDummyFS> writeToFile ./log/2024-08-31T14:04:04.141Z-scope1/2024-08-31T14:04:04.141Z.log : Subsequent logs are omitted...
[2024-08-31T14:04:04.141Z] Subsequent logs are omitted...
------
```

ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ä¿å­˜ã«ã‚‚åˆ¶é™ãŒé©ç”¨ã•ã‚Œã‚‹ã€‚

é€†ã«ã€`saveLogChunk`ã‚’å…ˆã«é©ç”¨ã™ã‚‹ã¨
```haskell
main :: IO ()
main = runApp . subsume . limitLogChunk 2 . saveLogChunk $ logExample
```

å®Ÿè¡Œçµæœ:
```
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z.log : out of chunk scope 1
[2024-08-31T14:05:03.211Z] out of chunk scope 1
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z.log : out of chunk scope 2
[2024-08-31T14:05:03.211Z] out of chunk scope 2
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z.log : out of chunk scope 3
[2024-08-31T14:05:03.211Z] out of chunk scope 3
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z.log : out of chunk scope 4
[2024-08-31T14:05:03.211Z] out of chunk scope 4
------
<runDummyFS> mkdir ./log/2024-08-31T14:05:03.211Z-scope1/
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.211Z.log : in scope1 1
[2024-08-31T14:05:03.211Z] in scope1 1
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.211Z.log : in scope1 2
[2024-08-31T14:05:03.211Z] in scope1 2
[2024-08-31T14:05:03.211Z] Subsequent logs are omitted...
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z.log : in scope1 3
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z.log : in scope1 4
------
<runDummyFS> mkdir ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z-scope2/
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z-scope2/2024-08-31T14:05:03.212Z.log : in scope2 1
[2024-08-31T14:05:03.212Z] in scope2 1
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z-scope2/2024-08-31T14:05:03.212Z.log : in scope2 2
[2024-08-31T14:05:03.212Z] in scope2 2
[2024-08-31T14:05:03.212Z] Subsequent logs are omitted...
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z-scope2/2024-08-31T14:05:03.212Z.log : in scope2 3
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z-scope2/2024-08-31T14:05:03.212Z.log : in scope2 4
------
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z.log : in scope1 5
<runDummyFS> writeToFile ./log/2024-08-31T14:05:03.211Z-scope1/2024-08-31T14:05:03.212Z.log : in scope1 6
```

åˆ¶é™å‰ã®ç”Ÿã®ãƒ­ã‚°ãŒãƒ•ã‚¡ã‚¤ãƒ«ã¸å‡ºåŠ›ã•ã‚Œã‚‹ã€‚

`subsume`ã¨`limitLogChunk`ã®é–“ã§`saveLogChunk`ã‚’é©ç”¨ã—ãŸã‚‰ã©ã†ãªã‚‹ã‹ï¼Ÿ
```haskell
main :: IO ()
main = runApp . subsume . saveLogChunk . limitLogChunk 2 $ logExample
```

```console
<runDummyFS> writeToFile ./log/2024-08-31T14:05:40.969Z.log : out of chunk scope 1
[2024-08-31T14:05:40.969Z] out of chunk scope 1
<runDummyFS> writeToFile ./log/2024-08-31T14:05:40.969Z.log : out of chunk scope 2
[2024-08-31T14:05:40.970Z] out of chunk scope 2
<runDummyFS> writeToFile ./log/2024-08-31T14:05:40.970Z.log : out of chunk scope 3
[2024-08-31T14:05:40.970Z] out of chunk scope 3
<runDummyFS> writeToFile ./log/2024-08-31T14:05:40.970Z.log : out of chunk scope 4
[2024-08-31T14:05:40.970Z] out of chunk scope 4
------
<runDummyFS> mkdir ./log/2024-08-31T14:05:40.970Z-scope1/
[2024-08-31T14:05:40.970Z] in scope1 1
[2024-08-31T14:05:40.970Z] in scope1 2
[2024-08-31T14:05:40.970Z] Subsequent logs are omitted...
------
[2024-08-31T14:05:40.970Z] in scope2 1
[2024-08-31T14:05:40.970Z] in scope2 2
[2024-08-31T14:05:40.970Z] Subsequent 
```

å…ˆç¨‹è¿°ã¹ãŸã‚ˆã†ã«ã€`subsume`ã«ã‚ˆã‚Šãƒ•ãƒƒã‚¯å…ˆã®`Log`ã‚¹ãƒ­ãƒƒãƒˆã¸ã¾ã¨ã‚ã‚‰ã‚Œã‚‹å‰ã®ã€ãƒªã‚¹ãƒˆå…ˆé ­ã®ãƒ•ãƒƒã‚¯å…ƒã®`Log`ã‚¹ãƒ­ãƒƒãƒˆã«ã¯ã€ãƒãƒ£ãƒ³ã‚¯å¤–ã«ã‚ã‚‹ãƒ­ã‚°ãŒä¿æŒã•ã‚Œã¦ã„ã‚‹ã®ã ã£ãŸã€‚`<|`æ¼”ç®—å­ã‚’åˆ¶ç´„ã¨ã™ã‚‹`interpose`ç³»é–¢æ•°ã¯ã€ãƒªã‚¹ãƒˆã®ã‚‚ã£ã¨ã‚‚ä¸Šä½ã®è©²å½“ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ãƒ•ãƒƒã‚¯ã‚’é©ç”¨ã™ã‚‹ã€‚ã—ãŸãŒã£ã¦ã€ã“ã®æœªå‡¦ç†ã®ãƒãƒ£ãƒ³ã‚¯å¤–ãƒ­ã‚°ãŒãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ä¿å­˜å‡¦ç†ã®å¯¾è±¡ã¨ãªã‚‹ã®ã ã€‚

# é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆå–ã‚Šæ‰±ã„ã®éš›ã®è«¸æ³¨æ„

é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æ‰±ã†éš›ã«ã¯ã€ã„ãã¤ã‹ã®è½ã¨ã—ç©´ãŒã‚ã‚‹ã€‚

## ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å¹²æ¸‰

å…ˆç¨‹ã®`limitLogChunk`é–¢æ•°ã«ãŠã„ã¦ã€`Log`ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’åˆ†ã‘ã¦`Log`ã‚’`interpretRec`ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã‚¹ãƒ­ãƒƒãƒˆã‚’åˆ†ã‘ãšã«`interposeRec`ã‚’ä½¿ã£ã¦æ›¸ãã“ã¨ã‚‚ã§ãã‚‹:

```haskell
-- | Limit the number of logs in a log chunk to the first @n@ logs.
limitLogChunk :: Log <| ef => Int -> '[LogChunk] :!! ef ~> '[LogChunk] :!! ef
limitLogChunk n = reinterpretRecH $ elabLimitLogChunk n

elabLimitLogChunk :: Log <| ef => Int -> Elab LogChunk ('[LogChunk] :!! ef)
elabLimitLogChunk n (LogChunk name a) =
    logChunk name do
        raiseH $ limitLog $ runLogChunk $ limitLogChunk n a
  where
    limitLog :: Log <| ef => '[] :!! ef ~> '[] :!! ef
    limitLog a' =
        evalState @Int 0 $
            raise a' & interposeRec \(Logging msg) -> do
                count <- get
                when (count < n) do
                    logging msg
                    when (count == n - 1) do
                        logging "Subsequent logs are omitted..."

                    modify @Int (+ 1)
```

ã“ã‚Œã‚’ä½¿ã†ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚`subsume`ã¯ä»˜ã‘ã‚‹å¿…è¦ãŒãªããªã‚‹ã€‚

```haskell
main :: IO ()
main = runApp . limitLogChunk 2 $ logExample
```

å®Ÿè¡Œçµæœ:
```console
[2024-08-31T14:15:14.169Z] out of chunk scope 1
[2024-08-31T14:15:14.169Z] out of chunk scope 2
[2024-08-31T14:15:14.169Z] out of chunk scope 3
[2024-08-31T14:15:14.169Z] out of chunk scope 4
------
[2024-08-31T14:15:14.169Z] in scope1 1
[2024-08-31T14:15:14.169Z] in scope1 2
[2024-08-31T14:15:14.169Z] Subsequent logs are omitted...
------
------
```

`scope1`ã«ã¤ã„ã¦ã¯æ­£å¸¸ã ãŒã€`scope2`ã®ãƒ­ã‚°ãŒæœ€åˆã‹ã‚‰æ¶ˆãˆã¦ã—ã¾ã£ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯ã€`interposeRec`ã®å†å¸°çš„ãªå‹•ä½œã‚’è€ƒãˆã‚‹ã¨ç†è§£ã§ãã‚‹ã€‚

ãƒ•ãƒƒã‚¯ã¯æœ¨ã®æ·±ã„ã¨ã“ã‚ã‹ã‚‰è¡Œã‚ã‚Œã‚‹ã®ã§ã€ã¾ãš`scope2`ã®ãƒ¬ãƒ™ãƒ«ã®ã‚‚ã®ãŒãƒ•ãƒƒã‚¯ã•ã‚Œã€
```haskell
logging "in scope2 1"
logging "in scope2 2"
logging "in scope2 3"
logging "in scope2 4"
```
ãŒ
```haskell
logging "in scope2 1"
logging "in scope2 2"
logging "Subsequent logs are omitted..."
```
ã¸ã¨å¤‰æ›ã•ã‚Œã‚‹ã€‚ã“ã“ã¾ã§ã¯å•é¡Œãªã„ã€‚

å•é¡Œã¯ã€æ¬¡ã«ã“ã‚ŒãŒ`scope1`ã®ãƒ¬ãƒ™ãƒ«ã«ç™»ã£ãŸã¨ãã§ã‚ã‚‹ã€‚ã„ã¾ã€`scope1`ã®ãƒ¬ãƒ™ãƒ«ã¯
```haskell
logging "in scope1 1"
logging "in scope1 2"
logging "in scope1 3"
logging "in scope1 4"

liftIO $ putStrLn "------"

logChunk "scope2" do
    logging "in scope2 1"
    logging "in scope2 2"
    logging "Subsequent logs are omitted..."

liftIO $ putStrLn "------"

logging "in scope1 5"
logging "in scope1 6"
```
ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚ã„ã¾ã€ã“ã®ä¸­ã®`logging`ã¯ã™ã¹ã¦åŒä¸€ã®ã‚¹ãƒ­ãƒƒãƒˆã«å…¥ã£ã¦ãŠã‚Šã€åŒºåˆ¥ã•ã‚Œã‚‹ã“ã¨ãŒãªã„ã€‚ã“ã®çŠ¶æ…‹ã§ãƒ•ãƒƒã‚¯ãŒè¡Œã‚ã‚Œã‚‹ã¨ã©ã†ãªã‚‹ã‹ï¼Ÿ
```haskell
logging "in scope1 1"
logging "in scope1 2"
logging "Subsequent logs are omitted..."

liftIO $ putStrLn "------"

logChunk "scope2" do
    pure ()

liftIO $ putStrLn "------"
```
ãã†ã€`scope1`ã®ãƒ¬ãƒ™ãƒ«ã®ãƒ­ã‚°ã ã‘ã§ãªãã€å…ˆç¨‹ã®`scope2`ã®ãƒ•ãƒƒã‚¯çµæœã®ãƒ­ã‚°ã‚‚åŒºåˆ¥ã•ã‚Œãšçœç•¥ã®å¯¾è±¡ã«ãªã£ã¦ã—ã¾ã†ã®ã ã€‚ã“ã‚Œã‚’é˜²ããŸã‚ã«ã¯ã€æ·±ã„éšå±¤ã‹ã‚‰ã®ãƒ•ãƒƒã‚¯çµæœãŒã•ã‚‰ãªã‚‹ãƒ•ãƒƒã‚¯ã®å¯¾è±¡ã«ã•ã‚Œã¦ã—ã¾ã†ã“ã¨ã‚’å›é¿ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã“ã®ãŸã‚ã«ã€ã‚¹ãƒ­ãƒƒãƒˆã‚’åˆ†ã‘ã‚‹å¿…è¦ãŒã‚ã£ãŸã®ã ã€‚

é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è§£é‡ˆã‚„ãƒ•ãƒƒã‚¯ã®éš›ã€ã‚¹ãƒ­ãƒƒãƒˆã‚’åˆ†ã‘ãšã«ç´ æœ´ã«æ“ä½œã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨ã€ã“ã®ã‚ˆã†ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’åŒä¸€ã‚¹ãƒ­ãƒƒãƒˆå†…ã§å¹²æ¸‰ã•ã›ã¦ã—ã¾ã„ã€çµæœã®äºˆæƒ³ãŒé›£ã—ããªã‚‹ã“ã¨ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚å ´åˆã«ã‚ˆã£ã¦ã¯ã€ã“ã®å¹²æ¸‰å‹•ä½œã‚’ã†ã¾ã„ã“ã¨æ´»ç”¨ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ãŒã§ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã—ã‹ã—å¤§æŠµã¯ã€å¹²æ¸‰ã®çµæœã‚’ã‚³ãƒ¼ãƒ‰ã‹ã‚‰äºˆæƒ³ã™ã‚‹ã“ã¨ã¯é›£ã—ã„ã ã‚ã†ã—ã€å¯èª­æ€§ã«æ”¯éšœãŒå‡ºã¦ãã‚‹ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ç´°ã‹ãåŒºåˆ‡ã‚Šã€å†è§£é‡ˆã«ãŠã„ã¦ã¯`interpret`ã‚’ä½¿ã†ãªã©ã—ã¦è§£é‡ˆå…ƒã®éšå±¤ã¨åˆ¥éšå±¤ã¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é€ä¿¡ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã®ãŒã€æ··ä¹±ãŒé¿ã‘ã‚‰ã‚Œã¦ã‚ˆã„ã ã‚ã†ã€‚ã‚‚ã¡ã‚ã‚“`interpose`ã‚’ä½¿ã†å ´åˆã§ã‚‚ã‚¹ãƒ­ãƒƒãƒˆã‚’åˆ†ã‘ã‚‹ã“ã¨ã¯å¯èƒ½ã ã€‚`raise`ç³»é–¢æ•°ã‚’ã†ã¾ãä½¿ã„ã€ãƒ•ãƒƒã‚¯å…ƒãƒ»å†è§£é‡ˆå…ƒã®ã‚¹ãƒ­ãƒƒãƒˆã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒé€ã‚‰ã‚Œãªã„ã‚ˆã†ã«ã—ã‚ˆã†ã€‚ã¾ãŸä»Šå›ã¯ä½¿ã‚ãªã‹ã£ãŸãŒã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚°ã‚’ã†ã¾ãä½¿ãŠã†ã€‚

## çŠ¶æ…‹ä»˜ãè§£é‡ˆ

# Heftiaã«ãŠã‘ã‚‹ç”¨èª

ã“ã“ã§ä¸€æ—¦ã€åŸºæœ¬çš„ãªæ¦‚å¿µã«ã¤ã„ã¦ã¾ã¨ã‚ã¤ã¤ã€å¿œç”¨çš„ãªæ¦‚å¿µã‚’ã„ãã¤ã‹å°å…¥ã™ã‚‹ã€‚

* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (effect)
ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰é€å‡ºã•ã‚Œã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚Šè§£é‡ˆã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã€‚ã¾ãŸã€ãã‚Œã‚’ä½œã‚Šå‡ºã™ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚

* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ (effect type)
ã„ãã¤ã‹ã®é–¢é€£ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç›´å’Œã§ã¾ã¨ã‚ãŸã‚‚ã®ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé›†åˆã®è¦ç´ ã¨ã—ã¦ç¾ã‚Œã‚‹ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚

* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ (effect interface)
ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã®å‹ã¨ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åå‰ã®çµ„ã®ã“ã¨ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åå‰ãŒ$N$ã€å¼•æ•°ã®æ•°ãŒ$n$ã€$i$ç•ªç›®ã®å¼•æ•°ã®å‹ãŒ$A_i$ã€æˆ»ã‚Šå€¤ã®å‹ãŒ$R$ã®ã¨ãã€çµ„$(N,\{A_i\}_{i=1,2,...,n},R)$ã®ã“ã¨ã€‚ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ å´ï¼‰ã¨ã‚¤ãƒ³ãƒ•ãƒ©ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å´ï¼‰ã®é–“ã®æ©‹æ¸¡ã—ã‚’ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã€‚æŠ½è±¡åŒ–å±¤ã€‚ã“ã‚Œã‚’å®šã‚ã‚‹ã“ã¨ã§ã€DSLï¼ˆãƒ‰ãƒ¡ã‚¤ãƒ³ç‰¹åŒ–è¨€èªï¼‰ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

    ä¾‹ãˆã°
    * Loggingã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯$N=$`Logging`, $A_1=$`Text`, $R=$`()`
    * LogChunkã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯$N=$`LogChunk`, $A_1=$`Text`, $A_2=$`f a`, $R=$`a`
        * ã“ã“ã§`a`ã¯å‹å¤‰æ•°ã§ã€`f`ã¯ç‰¹åˆ¥ã«ã‚­ãƒ£ãƒªã‚¢ã‚’è¡¨ã™

* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ  (effectful program)
è¤‡æ•°ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç‰¹å®šã®åˆ¶å¾¡æ§‹é€ ã®å½¢å¼ã«å¾“ã£ã¦ä¸¦ã¹ãŸã‚‚ã®ã€‚åˆ¶å¾¡æ§‹é€ ã®å½¢å¼ã«ã¯ãƒ¢ãƒŠãƒ‰ã®ä»–ã«ã‚¢ãƒ—ãƒªã‚«ãƒ†ã‚£ãƒ–ãªã©ãŒã‚ã‚‹ã€‚ãƒ¢ãƒŠãƒ‰ãªå½¢å¼ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãƒ¢ãƒŠãƒ‡ã‚£ãƒƒã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ  (monadic program) ã€ã‚¢ãƒ—ãƒªã‚«ãƒ†ã‚£ãƒ–ãªå½¢å¼ã®ã‚‚ã®ã¯ã‚¢ãƒ—ãƒªã‚«ãƒ†ã‚£ãƒ–ãƒ—ãƒ­ã‚°ãƒ©ãƒ  (applicative program) ã¨å‘¼ã¶ã€‚

* ã‚­ãƒ£ãƒªã‚¢ (carrier)
åˆ¶å¾¡æ§‹é€ ã®å½¢å¼ã‚’è¡¨ç¾ã™ã‚‹å‹ã‚¯ãƒ©ã‚¹ (`Monad`, `Applicative`ç­‰) ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ãªã‚‹ã€ã‚«ã‚¤ãƒ³ãƒ‰ãŒ`Type -> Type`ã®ãƒ‡ãƒ¼ã‚¿å‹ï¼ˆå‹æ§‹ç¯‰å­ï¼‰ã€‚ä¾‹ãˆã°ã€`IO`ãƒ¢ãƒŠãƒ‰ã¯ã‚­ãƒ£ãƒªã‚¢ã§ã‚ã‚‹ã€‚HeftiaãŒä½¿ç”¨ã™ã‚‹ã‚­ãƒ£ãƒªã‚¢ã¯ã‚³ãƒ¼ãƒ‰ä¸­ã§ã¯é€šå¸¸`(:!!)`æ¼”ç®—å­ã§è¡¨ã•ã‚Œã‚‹ã€‚å¤šç›¸åŒ–ã™ã‚‹å ´åˆã€å‹å¤‰æ•°`f`ã§è¡¨ã™ã€‚ãƒ¢ãƒŠãƒ‰ã®å ´åˆã¯ç‰¹ã«`m`ã€‚

* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆ
ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé›†åˆã‚’å‹ãƒ¬ãƒ™ãƒ«ãƒªã‚¹ãƒˆã¨ã—ã¦Haskellå†…ã§è¡¨ç¾ã—ãŸã‚‚ã®ã€‚

* è§£é‡ˆ (interpret/interpretation)ã€
ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«å¾“ã£ãŸãƒ‡ãƒ¼ã‚¿ã§ã‚ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ã€åˆ¥ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¸ã¨å¤‰æ›ã™ã‚‹ã“ã¨ã€‚å˜ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã§ã‚ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«ã€æŒ¯ã‚‹èˆã„ã¨ã—ã¦ã®æ„å‘³ä»˜ã‘ã‚’è¡Œã†ã€‚

* ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ (interpreter/è§£é‡ˆå™¨)
ä¸ãˆã‚‰ã‚ŒãŸè§£é‡ˆã®ä¸‹ã§ã€å…¥åŠ›ã•ã‚ŒãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒä¿æŒã—ã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ãã®è§£é‡ˆã‚’é©ç”¨ã—ã€åˆ¥ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¸ã¨å¤‰æ›ã—å‡ºåŠ›ã™ã‚‹ã‚ˆã†ãªHaskellä¸Šã®é–¢æ•°ã€‚

* è§£é‡ˆå°„ (interpretation morphism)

* è§£é‡ˆé–¢æ•° (interpreting function)
`interpret`, `interpretRec`, `interpretRecH`ç­‰ã®ã€è§£é‡ˆã‚’ã—ãŸã‚Šè§£é‡ˆå™¨ã‚’ä½œã£ãŸã‚Šã™ã‚‹ãŸã‚ã«Heftiaãƒ©ã‚¤ãƒ–ãƒ©ãƒªä¸Šã§ç”¨æ„ã•ã‚ŒãŸé–¢æ•°ã®ã“ã¨ã€‚

* ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
å¼•æ•°ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å«ã¾ãªã„ã‚‚ã®ã€‚ã‚ˆã‚Šå³å¯†ã«ã¯ã€å¼•æ•°éƒ¨ã®å‹$A$ä¸­ã«ã‚­ãƒ£ãƒªã‚¢ã®å‹å¤‰æ•°`f`ï¼ˆãƒ¢ãƒŠãƒ‰ã®å ´åˆ`m`ï¼‰ãŒå‡ºç¾ã—ãªã„ã‚‚ã®ã€‚

* é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã§ãªã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã€‚

* ãƒãƒ³ãƒ‰ãƒ« (handle) ã€ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° (handling) ã€ãƒãƒ³ãƒ‰ãƒ© (handler)
ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è§£é‡ˆã™ã‚‹ã“ã¨ã€‚

* æ•·è¡ (elaborate/elaboration) ã€æ•·è¡å™¨ (elaborator)
é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è§£é‡ˆã™ã‚‹ã“ã¨ã€‚

* çŠ¶æ…‹ä»˜ãè§£é‡ˆ (stateful interpretation)
ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è§£é‡ˆãŒã‚ã‚‹æ„å‘³ã§çŠ¶æ…‹ã«ä¾å­˜ã™ã‚‹ã¨ãã€ãã®è§£é‡ˆã¯çŠ¶æ…‹ä»˜ãè§£é‡ˆã§ã‚ã‚‹ã¨ã„ã†ã€‚å…·ä½“çš„ã«ã¯ã€è§£é‡ˆå°„ãŒmonad morphismã§ãªã„å ´åˆã€‚å¯¾ç¾©èªï¼ˆmonad morphismã§ã‚ã‚‹å ´åˆï¼‰ã¯ç„¡çŠ¶æ…‹è§£é‡ˆ (stateless interpretation) ã€‚


hefty algebraã®æå”±ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–ã‚Šæ‰±ã‚ã‚Œæ–¹ã«ãŠã„ã¦ã¯åŸå‰‡çš„ã«ã€
ä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¸ã¨è‡ªç”±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ï¼ˆä¸€éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è§£é‡ˆãƒ»å†è§£é‡ˆã‚’å¥½ãã«è¡Œã†ï¼‰ãŸã‚ã«ã¯ã€ã¾ãšã€Œä¸Šã«è¦†ã„ã‹ã¶ã•ã£ã¦ã„ã‚‹ã€é«˜éšã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è§£é‡ˆã‚’ã™ã¹ã¦çµ‚ãˆãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚

ã¤ã¾ã‚Šã€ã€Œã¾ãš`elaborate`ã›ã‚ˆã€ãã†ã™ã‚Œã°`interpret`ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚

åˆ¶é™ãŒå¼·ã„ã¨æ€ã‚ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã—ã‹ã—ã€ã“ã‚Œã¯è«–æ–‡ä¸­ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ã ãŒã€
ã“ã®åˆ¶é™ã¯ç¬¬ä¸€ã«ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã«ãŠã‘ã‚‹ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®æ­£å¸¸æ€§ã®ä¿è­·ã®ãŸã‚ã«é‡è¦ã§ã‚ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®çµæœã®äºˆæ¸¬æ€§ãŒå‘ä¸Šã—ã€ã‚·ãƒ³ãƒ—ãƒ«ã§ç›´æ„Ÿçš„ãªã‚‚ã®ã«ãªã‚‹ã€‚
ç¬¬äºŒã«ã€ã“ã®hefty algebraã«åŸºã¥ãæ–¹æ³•ã¯ã€åˆ¶é™ã¨å¼•ãæ›ãˆã«è‡ªç”±ã‚’å¼•ãå‡ºã™ã€‚
ã“ã‚Œã«ã¤ã„ã¦ã¯æ¬¡ã®ãƒ‘ãƒ¼ãƒˆã§è¿°ã¹ã‚‹ã€‚

# ã‚³ãƒ¼ãƒ‰å…¨ä½“

å‚è€ƒã¾ã§ã«ã€`limitLogChunk`ã€`saveLogChunk`ã®é †ç•ªã§elaboratorã‚’åˆæˆã—ãŸéš›ã®ã‚³ãƒ¼ãƒ‰ã®å…¨ä½“ã‚’æ²è¼‰ã™ã‚‹ã€‚

```hs
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module Main where

import Control.Effect.Class (SendIns (sendIns), type (<:), type (~>))
import Control.Effect.Class.Machinery.TH (makeEffectF, makeEffectH)
import Control.Effect.Class.Reader (Ask (ask), AskI, Local (local), LocalS)
import Control.Effect.Class.State (State (get), StateI, modify)
import Control.Effect.Freer (
    Fre,
    flipFreer,
    interpose,
    interpret,
    interpreted,
    liftLower,
    raise,
    raise2,
    runFreerEffects,
    type (<|),
 )
import Control.Effect.Handler.Heftia.Reader (interpretReader, liftReader)
import Control.Effect.Handler.Heftia.State (evalState)
import Control.Effect.Heftia (
    ForallHFunctor,
    Hef,
    elaborated,
    flipHeftia,
    hoistHeftiaEffects,
    hoistInterpose,
    interpretH,
    liftLowerH,
    runElaborate,
    type (<<|),
 )
import Control.Monad (when)
import Control.Monad.Trans.Heftia.Church (HeftiaChurchT)
import Data.Function ((&))
import Data.Hefty.Extensible (ExtensibleUnionH)
import Data.Hefty.Union (absurdUnionH, (|+:))
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.IO qualified as T
import Data.Time (UTCTime, getCurrentTime)
import Data.Time.Format.ISO8601 (iso8601Show)
import Prelude hiding (log)

class Log f where
    log :: Text -> f ()

makeEffectF ''Log

logToIO :: (IO <: Fre r m, Monad m) => Fre (LogI ': r) m ~> Fre r m
logToIO = interpret \(Log msg) -> sendIns $ T.putStrLn msg

class Time f where
    currentTime :: f UTCTime

makeEffectF ''Time

timeToIO :: (IO <: Fre r m, Monad m) => Fre (TimeI ': r) m ~> Fre r m
timeToIO = interpret \case
    CurrentTime -> sendIns getCurrentTime

logWithTime :: (LogI <| es, Time (Fre es m), Monad m) => Fre es m ~> Fre es m
logWithTime = interpose \(Log msg) -> do
    t <- currentTime
    log $ "[" <> T.pack (show t) <> "] " <> msg

-- | An effect that introduces a scope that represents a chunk of logs.
class LogChunk f where
    logChunk :: f a -> f a

makeEffectH ''LogChunk

-- | Output logs in log chunks as they are.
passthroughLogChunk ::
    (Monad m, ForallHFunctor r) =>
    Hef (LogChunkS ': r) m ~> Hef r m
passthroughLogChunk = interpretH \(LogChunk m) -> m

-- | Limit the number of logs in a log chunk to the first @n@ logs.
limitLogChunk ::
    forall m.
    (LogChunk m, Log m, Monad m) =>
    Int ->
    LogChunkS (Fre '[LogI] m) ~> m
limitLogChunk n (LogChunk a) =
    logChunk
        . interpreted
        . evalState 0
        . interpretLog
        . flipFreer
        . raise
        $ a
  where
    interpretLog :: Fre '[LogI, StateI Int] m ~> Fre '[StateI Int] m
    interpretLog =
        interpret \(Log msg) -> do
            count <- get
            when (count <= n) do
                liftLower $
                    if count == n
                        then log "LOG OMITTED..."
                        else log msg

                modify @Int (+ 1)

class FileSystem f where
    mkdir :: FilePath -> f ()
    writeFS :: FilePath -> String -> f ()

makeEffectF ''FileSystem

runDummyFS :: (IO <: Fre r m, Monad m) => Fre (FileSystemI ': r) m ~> Fre r m
runDummyFS = interpret \case
    Mkdir path -> sendIns $ putStrLn $ "<runDummyFS> mkdir " <> path
    WriteFS path content -> sendIns $ putStrLn $ "<runDummyFS> writeFS " <> path <> " : " <> content

-- | Create directories according to the log-chunk structure and save one log in one file.
saveLogChunk ::
    forall es es' m.
    ( LogChunkS <<| es
    , LogI <| es'
    , FileSystem (Fre es' m)
    , Time (Fre es' m)
    , Monad m
    , ForallHFunctor es
    ) =>
    Hef (LogChunkS ': es) (Fre (LogI ': es') m) ~> Hef es (Fre (LogI ': es') m)
saveLogChunk =
    interpretReader ("./log_chunks/" :: FilePath)
        . hoistHeftiaEffects flipFreer
        . interpretLogChunk
        . hoistHeftiaEffects flipFreer
        . flipHeftia
        . liftReader
  where
    interpretLogChunk ::
        Hef (LogChunkS ': LocalS FilePath ': es) (Fre (LogI ': AskI FilePath ': es') m)
            ~> Hef (LocalS FilePath ': es) (Fre (LogI ': AskI FilePath ': es') m)
    interpretLogChunk =
        interpretH \(LogChunk a) -> logChunk do
            chunkBeginAt <- currentTime & raise2 & liftLowerH
            local @FilePath (++ iso8601Show chunkBeginAt ++ "/") do
                newLogChunkDir <- ask & liftLowerH
                mkdir newLogChunkDir & raise2 & liftLowerH
                a & hoistInterpose \(Log msg) -> do
                    logAt <- currentTime & raise2
                    saveDir <- ask
                    log msg & raise2
                    writeFS (saveDir ++ iso8601Show logAt ++ ".log") (show msg) & raise2

logs :: (LogChunk m, Log m, IO <: m, Monad m) => m ()
logs =
    logChunk do
        log "foo"
        log "bar"
        log "baz"
        log "qux"

        sendIns $ putStrLn "------"

        logChunk do
            log "hoge"
            log "piyo"
            log "fuga"
            log "hogera"

        sendIns $ putStrLn "------"

        log "quux"
        log "foobar"

main :: IO ()
main =
    runFreerEffects
        . logToIO
        . timeToIO
        . logWithTime
        . runDummyFS
        . interpret (\(Log m) -> log m)
        . elaborated
        . passthroughLogChunk
        . saveLogChunk
        . interpreted
        . interpret (\(Log m) -> log m)
        . runElaborate @_ @HeftiaChurchT @ExtensibleUnionH
            (liftLower . limitLogChunk 2 |+: absurdUnionH)
        $ logs

{- Execution result:
<runDummyFS> mkdir ./log_chunks/2023-09-15T13:08:58.061694233Z/
[2023-09-15 13:08:58.061839747 UTC] foo
<runDummyFS> writeFS ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.061832603Z.log : "foo"
[2023-09-15 13:08:58.061906122 UTC] bar
<runDummyFS> writeFS ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.061898517Z.log : "bar"
[2023-09-15 13:08:58.06196369 UTC] LOG OMITTED...
<runDummyFS> writeFS ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.061956957Z.log : "LOG OMITTED..."
------
<runDummyFS> mkdir ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.06204337Z/
[2023-09-15 13:08:58.062120395 UTC] hoge
<runDummyFS> writeFS ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.06204337Z/2023-09-15T13:08:58.062108332Z.log : "hoge"
[2023-09-15 13:08:58.062202208 UTC] piyo
<runDummyFS> writeFS ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.06204337Z/2023-09-15T13:08:58.062190025Z.log : "piyo"
[2023-09-15 13:08:58.062287759 UTC] LOG OMITTED...
<runDummyFS> writeFS ./log_chunks/2023-09-15T13:08:58.061694233Z/2023-09-15T13:08:58.06204337Z/2023-09-15T13:08:58.062269415Z.log : "LOG OMITTED..."
------
-}
```
